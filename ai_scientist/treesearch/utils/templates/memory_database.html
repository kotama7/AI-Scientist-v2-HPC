<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script>
      // Check if we're running under Live Server
      if (window.location.hostname === '127.0.0.1' || window.location.hostname === 'localhost') {
          let lastModified = '';

          // Check for file changes every second
          setInterval(async () => {
              try {
                  const response = await fetch(window.location.href, { method: 'HEAD' });
                  const currentModified = response.headers.get('last-modified');

                  if (lastModified && lastModified !== currentModified) {
                      window.location.reload();
                  }

                  lastModified = currentModified;
              } catch (e) {
                  console.error('Error checking for updates:', e);
              }
          }, 1000);
      }
  </script>
    <title>__EXPERIMENT_NAME__ - Memory Database Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a2e;
            color: #eee;
            display: flex;
            height: 100vh;
        }
        #canvas-container {
            width: 35vw;
            height: 100vh;
            background-color: #16213e;
            position: relative;
        }
        #info-container {
            width: 65vw;
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
            background-color: #0f0f23;
        }
        .header {
            background-color: #1a1a2e;
            padding: 15px;
            border-bottom: 2px solid #e94560;
            margin-bottom: 20px;
        }
        .header h1 {
            font-size: 1.5rem;
            color: #e94560;
        }
        .header .node-info {
            font-size: 0.9rem;
            color: #888;
            margin-top: 5px;
        }
        /* Split-phase navigation */
        .split-phase-nav {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #16213e;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .split-phase-nav.hidden {
            display: none;
        }
        .split-phase-label {
            font-size: 0.85rem;
            color: #888;
            margin-right: 10px;
        }
        .split-phase-arrow {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
            background-color: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .split-phase-arrow:hover:not(:disabled) {
            background-color: #e94560;
            border-color: #e94560;
        }
        .split-phase-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .split-phase-current {
            flex: 1;
            text-align: center;
            padding: 8px 16px;
            background-color: #0f0f23;
            border-radius: 4px;
            min-width: 200px;
        }
        .split-phase-name {
            font-weight: bold;
            color: #4dabf7;
            font-size: 1rem;
        }
        .split-phase-status {
            font-size: 0.75rem;
            margin-top: 4px;
        }
        .split-phase-status.success {
            color: #69db7c;
        }
        .split-phase-status.failed {
            color: #ff6b6b;
        }
        .split-phase-status.pending {
            color: #888;
        }
        .split-phase-timeline {
            display: flex;
            gap: 4px;
            margin-left: 15px;
        }
        .timeline-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #333;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timeline-dot.active {
            background-color: #4dabf7;
            transform: scale(1.3);
        }
        .timeline-dot.success {
            background-color: #69db7c;
        }
        .timeline-dot.failed {
            background-color: #ff6b6b;
        }
        .timeline-dot.memory {
            background-color: #b197fc;
        }
        .timeline-dot:hover {
            transform: scale(1.3);
        }
        /* Memory injection display */
        .memory-injection-card {
            background-color: #1a1a2e;
            border-left: 3px solid #b197fc;
            border-radius: 4px;
            padding: 12px 15px;
            margin-bottom: 10px;
        }
        .memory-injection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .memory-injection-task {
            color: #b197fc;
            font-weight: bold;
        }
        .memory-injection-size {
            color: #888;
            font-size: 0.85rem;
        }
        .memory-injection-content {
            background-color: #0f0f23;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 300px;
            overflow-y: auto;
            color: #ccc;
        }
        .memory-section {
            margin-bottom: 25px;
            background-color: #16213e;
            border-radius: 8px;
            overflow: hidden;
        }
        .section-header {
            background-color: #1a1a2e;
            padding: 12px 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-left: 3px solid #e94560;
        }
        .section-header:hover {
            background-color: #222;
        }
        .section-content {
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
        }
        .section-content.collapsed {
            display: none;
        }
        .kv-item {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #0f0f23;
            border-radius: 4px;
            border-left: 3px solid #4dabf7;
        }
        .kv-key {
            color: #4dabf7;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .kv-value {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: monospace;
            font-size: 0.85rem;
            color: #ccc;
        }
        .event-item {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #0f0f23;
            border-radius: 4px;
            border-left: 3px solid #69db7c;
        }
        .event-item.memory-injection {
            border-left-color: #b197fc;
            background-color: #1a1525;
        }
        .event-kind {
            color: #69db7c;
            font-weight: bold;
        }
        .event-text {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: monospace;
            font-size: 0.85rem;
            margin-top: 5px;
        }
        .event-meta {
            font-size: 0.75rem;
            color: #666;
            margin-top: 5px;
        }
        .archival-item {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #0f0f23;
            border-radius: 4px;
            border-left: 3px solid #ffd43b;
        }
        .archival-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 8px;
        }
        .archival-tag {
            background-color: #333;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            color: #ffd43b;
        }
        .archival-text {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
        }
        .no-data {
            color: #666;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }
        .count-badge {
            background-color: #333;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
        }
        .expand-icon {
            transition: transform 0.2s;
        }
        .expand-icon.collapsed {
            transform: rotate(-90deg);
        }
        /* Data group styles */
        .data-group {
            margin-bottom: 30px;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        .data-group-header {
            background-color: #1a1a2e;
            padding: 12px 15px;
            font-weight: bold;
            font-size: 1.1rem;
            border-bottom: 2px solid #e94560;
        }
        .data-group-header.inherited {
            border-bottom-color: #ffd43b;
            color: #ffd43b;
        }
        /* Inherited item styles */
        .kv-item.inherited {
            opacity: 0.8;
            border-left-color: #888;
        }
        .event-item.inherited {
            opacity: 0.8;
            border-left-color: #888;
        }
        .archival-item.inherited {
            opacity: 0.8;
            border-left-color: #888;
        }
        /* Ancestor info */
        .ancestor-chain {
            font-size: 0.8rem;
            color: #888;
            margin: 10px 15px;
            padding: 8px;
            background-color: #0f0f23;
            border-radius: 4px;
        }
        .ancestor-chain a {
            color: #4dabf7;
            cursor: pointer;
            text-decoration: none;
        }
        .ancestor-chain a:hover {
            text-decoration: underline;
        }
        /* Memory calls (reads/operations log) */
        .memory-call-item {
            padding: 12px;
            margin: 8px 0;
            background-color: #1a1a2e;
            border-left: 3px solid #f59f00;
            border-radius: 4px;
        }
        .memory-call-item.read {
            border-left-color: #51cf66;
        }
        .memory-call-item.write {
            border-left-color: #ff6b6b;
        }
        .memory-call-item.fork {
            border-left-color: #4dabf7;
        }
        .memory-call-item.system {
            border-left-color: #868e96;
        }
        .memory-call-item.llm {
            border-left-color: #be4bdb;
        }
        .memory-call-item.inherited {
            opacity: 0.8;
            border-left-color: #888;
        }
        .memory-call-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .memory-call-op {
            font-weight: bold;
            font-size: 0.9rem;
        }
        .memory-call-op.read { color: #51cf66; }
        .memory-call-op.write { color: #ff6b6b; }
        .memory-call-op.fork { color: #4dabf7; }
        .memory-call-op.system { color: #868e96; }
        .memory-call-op.llm { color: #be4bdb; }
        .memory-call-op.other { color: #f59f00; }
        .memory-call-time {
            font-size: 0.75rem;
            color: #888;
        }
        .memory-call-phase {
            font-size: 0.8rem;
            color: #b197fc;
            margin-bottom: 4px;
        }
        .memory-call-details {
            font-size: 0.85rem;
            color: #aaa;
            background-color: #0f0f23;
            padding: 8px;
            border-radius: 4px;
            margin-top: 8px;
        }
        .memory-call-detail-row {
            display: flex;
            margin: 2px 0;
        }
        .memory-call-detail-key {
            color: #888;
            min-width: 120px;
        }
        .memory-call-detail-value {
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info-container">
        <div class="header">
            <h1>__EXPERIMENT_NAME__</h1>
            <div class="node-info" id="current-node-info">Click a node to view memory state</div>
        </div>
        <div class="split-phase-nav hidden" id="split-phase-nav">
            <span class="split-phase-label">ÂÆüË°å„Éï„Çß„Éº„Ç∫:</span>
            <button class="split-phase-arrow" id="prev-phase" onclick="navigateSplitPhase(-1)">‚óÄ</button>
            <div class="split-phase-current">
                <div class="split-phase-name" id="current-phase-name">-</div>
                <div class="split-phase-status" id="current-phase-status">-</div>
            </div>
            <button class="split-phase-arrow" id="next-phase" onclick="navigateSplitPhase(1)">‚ñ∂</button>
            <div class="split-phase-timeline" id="phase-timeline"></div>
        </div>
        <div id="memory-content"></div>
    </div>

    <script>
const memoryData = __JS_DATA__;

let nodes = [];
let edges = [];
let selectedNodeIndex = null;
let selectedPhase = null;
let currentSplitPhaseIndex = -1;
let nodeSplitPhases = [];

// Split-phase execution order (matches the order in parallel_agent.py)
const SPLIT_PHASE_ORDER = [
    { kind: 'node_created', label: 'Node Created', description: '„Éé„Éº„ÉâÂàùÊúüÂåñ' },
    { kind: 'memory_injected', label: 'Memory Inject', description: '„É°„É¢„É™Ê≥®ÂÖ•', isMemory: true },
    { kind: 'phase1_complete', label: 'Phase 1', description: '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ/„Ç§„É≥„Çπ„Éà„Éº„É´ÂÆå‰∫Ü' },
    { kind: 'phase1_failed', label: 'Phase 1', description: '„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ/„Ç§„É≥„Çπ„Éà„Éº„É´Â§±Êïó', isError: true },
    { kind: 'coding_complete', label: 'Coding', description: '„Éï„Ç°„Ç§„É´ÁîüÊàêÂÆå‰∫Ü' },
    { kind: 'coding_failed', label: 'Coding', description: '„Éï„Ç°„Ç§„É´ÁîüÊàêÂ§±Êïó', isError: true },
    { kind: 'compile_complete', label: 'Compile', description: '„Ç≥„É≥„Éë„Ç§„É´ÂÆå‰∫Ü' },
    { kind: 'compile_failed', label: 'Compile', description: '„Ç≥„É≥„Éë„Ç§„É´Â§±Êïó', isError: true },
    { kind: 'run_complete', label: 'Run', description: 'ÂÆüË°åÂÆå‰∫Ü' },
    { kind: 'run_failed', label: 'Run', description: 'ÂÆüË°åÂ§±Êïó', isError: true },
    { kind: 'node_result', label: 'Node Result', description: '„Éé„Éº„ÉâÁµêÊûú' },
    { kind: 'metrics_extracted', label: 'Metrics', description: '„É°„Éà„É™„ÇØ„ÇπÊäΩÂá∫ÂÆå‰∫Ü' },
    { kind: 'metrics_failed', label: 'Metrics', description: '„É°„Éà„É™„ÇØ„ÇπÊäΩÂá∫Â§±Êïó', isError: true },
    { kind: 'node_summary', label: 'Summary', description: '„Éé„Éº„Éâ„Çµ„Éû„É™„ÉºÁîüÊàê' },
];

// Memory injection task hints to phase mapping
const MEMORY_TASK_HINTS = {
    'draft': 'Phase 2 Draft',
    'debug': 'Phase 2 Debug',
    'improve': 'Phase 2 Improve',
    'phase1_iterative': 'Phase 1 Iterative',
    'phase2_draft': 'Phase 2 Draft (Split)',
    'phase2_debug': 'Phase 2 Debug (Split)',
    'phase2_improve': 'Phase 2 Improve (Split)',
    'phase2_coding': 'Phase 2 Coding',
    'phase2_hyperparam': 'Phase 2 Hyperparam',
    'phase2_ablation': 'Phase 2 Ablation',
    'parse_metrics': 'Metrics Parsing',
    'metrics_extraction': 'Metrics Extraction',
    'execution_review': 'Execution Review',
    'hyperparam_node': 'Hyperparam Tuning',
    'ablation_node': 'Ablation Study',
    'journal_summary': 'Journal Summary',
    'datasets_successfully_tested': 'Datasets Tested',
};

class Node {
    constructor(x, y, index, data) {
        this.x = x;
        this.y = y;
        this.index = index;
        this.data = data;
        this.visible = true;
        this.selected = false;
        this.radius = 18;
        this.isVirtual = data.is_virtual || data.node_uid === 'root' || data.node_uid === 'none_root';
    }

    render(p5) {
        if (!this.visible) return;

        p5.push();
        p5.translate(this.x, this.y);

        p5.noStroke();
        p5.fill(0, 0, 0, 50);
        p5.ellipse(2, 2, this.radius * 2);

        if (this.selected) {
            p5.fill(233, 69, 96);
        } else if (this.isVirtual) {
            // Virtual node: gray color
            p5.fill(100, 100, 100);
        } else {
            p5.fill(77, 171, 247);
        }
        p5.ellipse(0, 0, this.radius * 2);

        p5.fill(255);
        p5.textAlign(p5.CENTER, p5.CENTER);
        p5.textSize(10);
        // Show "V" for virtual nodes instead of index
        p5.text(this.isVirtual ? 'V' : this.index, 0, 0);

        p5.pop();
    }

    isMouseOver(p5) {
        const d = p5.dist(p5.mouseX, p5.mouseY, this.x, this.y);
        return d < this.radius;
    }
}

class Edge {
    constructor(parent, child) {
        this.parent = parent;
        this.child = child;
    }

    render(p5) {
        p5.stroke(100);
        p5.strokeWeight(1.5);
        p5.noFill();

        const midY = this.parent.y + (this.child.y - this.parent.y) * 0.5;

        p5.beginShape();
        p5.vertex(this.parent.x, this.parent.y);
        p5.vertex(this.parent.x, midY);
        p5.vertex(this.child.x, midY);
        p5.vertex(this.child.x, this.child.y);
        p5.endShape();
    }
}

function createSketch() {
    return function(p5) {
        p5.setup = function() {
            const canvas = p5.createCanvas(
                document.getElementById('canvas-container').offsetWidth,
                window.innerHeight
            );
            canvas.parent('canvas-container');

            for (let i = 0; i < memoryData.layout.length; i++) {
                const [nx, ny] = memoryData.layout[i];
                const node = new Node(
                    nx * p5.width * 0.85 + p5.width * 0.075,
                    ny * p5.height * 0.85 + p5.height * 0.075,
                    i,
                    memoryData.nodes[i]
                );
                nodes.push(node);
            }

            for (const [parentIdx, childIdx] of memoryData.edges) {
                if (nodes[parentIdx] && nodes[childIdx]) {
                    edges.push(new Edge(nodes[parentIdx], nodes[childIdx]));
                }
            }

            if (nodes.length > 0) {
                selectNode(0);
            }
        };

        p5.draw = function() {
            p5.background(22, 33, 62);

            for (const edge of edges) {
                edge.render(p5);
            }

            for (const node of nodes) {
                node.render(p5);
            }

            p5.cursor(p5.ARROW);
            for (const node of nodes) {
                if (node.isMouseOver(p5)) {
                    p5.cursor(p5.HAND);
                    break;
                }
            }
        };

        p5.mousePressed = function() {
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].isMouseOver(p5)) {
                    selectNode(i);
                    break;
                }
            }
        };

        p5.windowResized = function() {
            p5.resizeCanvas(
                document.getElementById('canvas-container').offsetWidth,
                window.innerHeight
            );
        };
    };
}

function selectNode(index) {
    selectedNodeIndex = index;
    selectedPhase = null;
    currentSplitPhaseIndex = -1;
    nodeSplitPhases = [];

    for (let i = 0; i < nodes.length; i++) {
        nodes[i].selected = (i === index);
    }

    const nodeData = memoryData.nodes[index];
    const isVirtual = nodeData.is_virtual || nodeData.node_uid === 'root' || nodeData.node_uid === 'none_root';

    // Display node info with virtual node indicator
    if (isVirtual) {
        document.getElementById('current-node-info').innerHTML =
            `<span style="color: #888;">Virtual Node („ÉÑ„É™„Éº„É´„Éº„Éà) | Branch: ${nodeData.branch_id.substring(0, 8)}...</span>`;
    } else {
        document.getElementById('current-node-info').innerHTML =
            `Node ${index} | Branch: ${nodeData.branch_id.substring(0, 8)}... | UID: ${nodeData.node_uid || 'unknown'}`;
    }

    // For virtual nodes, show message
    if (isVirtual) {
        document.getElementById('split-phase-nav').classList.add('hidden');
        document.getElementById('memory-content').innerHTML = `
            <div style="text-align: center; padding: 40px; color: #888;">
                <div style="font-size: 2rem; margin-bottom: 15px;">üå≥</div>
                <div style="font-size: 1.1rem; margin-bottom: 10px;">Virtual Node</div>
                <div>„Åì„ÅÆ„Éé„Éº„Éâ„ÅØ„ÉÑ„É™„ÉºÊßãÈÄ†„ÅÆ„É´„Éº„Éà„Éé„Éº„Éâ„Åß„Åô„ÄÇ</div>
                <div>ÂÆüÈ®ì„Éá„Éº„Çø„ÇíÊåÅ„Å§Â≠ê„Éé„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</div>
            </div>
        `;
        return;
    }

    // Setup split-phase navigation
    setupSplitPhaseNav(nodeData);

    // Default to ALL view
    selectPhase('ALL');
}

function setupSplitPhaseNav(nodeData) {
    const ownEvents = nodeData.own_events || nodeData.events || [];

    // Detect split-phase events present in this node
    // For memory_injected events, collect all of them (there can be multiple)
    nodeSplitPhases = [];
    const memoryInjections = ownEvents.filter(e => e.kind === 'memory_injected');

    for (const phaseInfo of SPLIT_PHASE_ORDER) {
        if (phaseInfo.kind === 'memory_injected') {
            // Add all memory injection events
            for (const memEvent of memoryInjections) {
                const taskHint = memEvent.task_hint || 'unknown';
                const phaseName = MEMORY_TASK_HINTS[taskHint] || taskHint;
                nodeSplitPhases.push({
                    ...phaseInfo,
                    event: memEvent,
                    label: `üíæ ${phaseName}`,
                    description: `„É°„É¢„É™Ê≥®ÂÖ•: ${phaseName}`,
                    status: 'memory',
                    taskHint: taskHint,
                });
            }
        } else {
            const matchingEvent = ownEvents.find(e => e.kind === phaseInfo.kind);
            if (matchingEvent) {
                nodeSplitPhases.push({
                    ...phaseInfo,
                    event: matchingEvent,
                    status: phaseInfo.isError ? 'failed' : 'success'
                });
            }
        }
    }

    const navContainer = document.getElementById('split-phase-nav');
    const timeline = document.getElementById('phase-timeline');

    // Show if there are any events (including memory injections)
    const hasSplitPhaseEvents = nodeSplitPhases.some(p =>
        p.kind.includes('phase1') || p.kind.includes('coding') ||
        p.kind.includes('compile') || p.kind.includes('run_') ||
        p.kind === 'memory_injected'
    );

    if (hasSplitPhaseEvents && nodeSplitPhases.length > 1) {
        navContainer.classList.remove('hidden');

        // Build timeline dots
        timeline.innerHTML = nodeSplitPhases.map((phase, idx) => {
            const statusClass = phase.status || 'pending';
            return `<div class="timeline-dot ${statusClass}"
                        onclick="selectSplitPhase(${idx})"
                        title="${phase.label}: ${phase.description}"></div>`;
        }).join('');

        // Start at first phase
        currentSplitPhaseIndex = 0;
        updateSplitPhaseDisplay();
    } else {
        navContainer.classList.add('hidden');
    }
}

function navigateSplitPhase(direction) {
    const newIndex = currentSplitPhaseIndex + direction;
    if (newIndex >= 0 && newIndex < nodeSplitPhases.length) {
        selectSplitPhase(newIndex);
    }
}

function selectSplitPhase(index) {
    currentSplitPhaseIndex = index;
    updateSplitPhaseDisplay();
    displaySplitPhaseMemory();
}

function updateSplitPhaseDisplay() {
    if (currentSplitPhaseIndex < 0 || currentSplitPhaseIndex >= nodeSplitPhases.length) return;

    const phase = nodeSplitPhases[currentSplitPhaseIndex];

    document.getElementById('current-phase-name').textContent = phase.label;
    const statusEl = document.getElementById('current-phase-status');
    statusEl.textContent = phase.description;
    statusEl.className = 'split-phase-status ' + (phase.status || 'pending');

    // Update arrow buttons
    document.getElementById('prev-phase').disabled = currentSplitPhaseIndex === 0;
    document.getElementById('next-phase').disabled = currentSplitPhaseIndex === nodeSplitPhases.length - 1;

    // Update timeline dots
    const dots = document.querySelectorAll('.timeline-dot');
    dots.forEach((dot, idx) => {
        dot.classList.toggle('active', idx === currentSplitPhaseIndex);
    });
}

function displaySplitPhaseMemory() {
    if (currentSplitPhaseIndex < 0) return;

    const nodeData = memoryData.nodes[selectedNodeIndex];
    const currentPhase = nodeSplitPhases[currentSplitPhaseIndex];

    // Get all events up to and including current phase
    const ownEvents = nodeData.own_events || nodeData.events || [];
    const currentPhaseIdx = SPLIT_PHASE_ORDER.findIndex(p => p.kind === currentPhase.kind);

    // Filter events: show only events that occurred up to this phase
    const phaseKindsUpToCurrent = SPLIT_PHASE_ORDER
        .slice(0, currentPhaseIdx + 1)
        .map(p => p.kind);

    const visibleEvents = ownEvents.filter(e => phaseKindsUpToCurrent.includes(e.kind));

    // Render memory state at this phase
    const container = document.getElementById('memory-content');

    const ownCoreKV = nodeData.own_core_kv || nodeData.core_kv || [];
    const ownArchival = nodeData.own_archival || nodeData.archival || [];
    const inheritedCoreKV = nodeData.inherited_core_kv || [];
    const inheritedEvents = nodeData.inherited_events || [];
    const inheritedArchival = nodeData.inherited_archival || [];
    const ancestors = nodeData.ancestors || [];

    let html = '';

    // Phase indicator with different style for memory injection
    const phaseColor = currentPhase.kind === 'memory_injected' ? '#b197fc' : '#4dabf7';
    html += `<div style="background: #1a1a2e; padding: 10px 15px; border-radius: 8px; margin-bottom: 15px; border-left: 3px solid ${phaseColor};">
        <strong style="color: ${phaseColor};">üìç ${currentPhase.label}</strong>
        <span style="color: #888; margin-left: 10px;">${currentPhase.description}</span>
        <span style="color: #666; margin-left: 10px;">
            (${currentSplitPhaseIndex + 1}/${nodeSplitPhases.length} „Éï„Çß„Éº„Ç∫)
        </span>
    </div>`;

    // If this is a memory injection event, show the injected memory details
    if (currentPhase.kind === 'memory_injected' && currentPhase.event) {
        const memEvent = currentPhase.event;
        const taskHint = memEvent.task_hint || currentPhase.taskHint || 'unknown';
        const memorySize = memEvent.memory_size || 0;
        const summary = memEvent.summary || '';

        // Extract memory content from summary (after the "---" line)
        const contentMatch = summary.split('---\n');
        const memoryContent = contentMatch.length > 1 ? contentMatch[1] : summary;

        html += `<div class="memory-injection-card">
            <div class="memory-injection-header">
                <span class="memory-injection-task">üíæ Ê≥®ÂÖ•„Åï„Çå„Åü„É°„É¢„É™: ${MEMORY_TASK_HINTS[taskHint] || taskHint}</span>
                <span class="memory-injection-size">${memorySize.toLocaleString()} ÊñáÂ≠ó</span>
            </div>
            <div class="memory-injection-content">${escapeHtml(memoryContent)}</div>
        </div>`;
    }

    // Own data at this phase
    html += '<div class="data-group"><div class="data-group-header">„Åì„ÅÆ„Éï„Çß„Éº„Ç∫„Åæ„Åß„ÅÆ„Éá„Éº„Çø</div>';

    html += createSection(
        'Working Context (Core KV)',
        renderCoreKV(ownCoreKV),
        ownCoreKV.length,
        true
    );

    html += createSection(
        'Recall Storage (Events)',
        renderEvents(visibleEvents),
        visibleEvents.length,
        true
    );

    // Filter archival by events up to this phase (approximate by tags)
    html += createSection(
        'Archive Storage',
        renderArchival(ownArchival),
        ownArchival.length,
        true
    );

    html += '</div>';

    // Inherited data
    const hasInherited = inheritedCoreKV.length + inheritedEvents.length + inheritedArchival.length > 0;

    if (hasInherited) {
        html += '<div class="data-group"><div class="data-group-header inherited">Á∂ôÊâø„Åï„Çå„Åü„Éá„Éº„ÇøÔºàÁ•ñÂÖà„Éé„Éº„Éâ„Åã„ÇâÔºâ</div>';
        html += renderAncestorChain(ancestors);

        html += createSection(
            'Working Context (Core KV)',
            renderCoreKV(inheritedCoreKV, true),
            inheritedCoreKV.length,
            false
        );

        html += createSection(
            'Recall Storage (Events)',
            renderEvents(inheritedEvents, true),
            inheritedEvents.length,
            false
        );

        html += createSection(
            'Archive Storage',
            renderArchival(inheritedArchival, true),
            inheritedArchival.length,
            false
        );

        html += '</div>';
    }

    container.innerHTML = html;
}

function selectPhase(phase) {
    selectedPhase = phase;

    const nodeData = memoryData.nodes[selectedNodeIndex];

    if (phase === 'ALL' || phase === 'summary') {
        displayAllMemory(nodeData);
    } else {
        displayPhaseMemory(nodeData, phase);
    }
}

function escapeHtml(text) {
    if (!text) return '';
    return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function createSection(title, content, count, defaultExpanded = true) {
    const expandedClass = defaultExpanded ? '' : 'collapsed';
    const iconClass = defaultExpanded ? '' : 'collapsed';

    return `
        <div class="memory-section">
            <div class="section-header" onclick="toggleSection(this)">
                <span>${title} <span class="count-badge">${count}</span></span>
                <span class="expand-icon ${iconClass}">‚ñº</span>
            </div>
            <div class="section-content ${expandedClass}">
                ${content || '<div class="no-data">No data</div>'}
            </div>
        </div>
    `;
}

function toggleSection(header) {
    const content = header.nextElementSibling;
    const icon = header.querySelector('.expand-icon');
    content.classList.toggle('collapsed');
    icon.classList.toggle('collapsed');
}

function renderCoreKV(items, isInherited = false) {
    if (!items || items.length === 0) return '';
    const inheritedClass = isInherited ? 'inherited' : '';

    return items.map(item => `
        <div class="kv-item ${inheritedClass}">
            <div class="kv-key">${escapeHtml(item.key)}</div>
            <div class="kv-value">${escapeHtml(item.value)}</div>
        </div>
    `).join('');
}

function renderEvents(items, isInherited = false) {
    if (!items || items.length === 0) return '';
    const inheritedClass = isInherited ? 'inherited' : '';

    return items.map(item => {
        const isMemoryInjection = item.kind === 'memory_injected';
        const kindClass = isMemoryInjection ? 'memory-injection' : '';
        const taskHint = item.task_hint ? ` (${MEMORY_TASK_HINTS[item.task_hint] || item.task_hint})` : '';
        const memorySize = item.memory_size ? ` [${item.memory_size.toLocaleString()} chars]` : '';

        return `
        <div class="event-item ${inheritedClass} ${kindClass}">
            <div class="event-kind" ${isMemoryInjection ? 'style="color: #b197fc;"' : ''}>${escapeHtml(item.kind)}${taskHint}${memorySize}</div>
            <div class="event-text">${escapeHtml(item.text)}</div>
            <div class="event-meta">
                Phase: ${item.phase || 'N/A'} |
                Tags: ${(item.tags || []).join(', ')}
            </div>
        </div>
    `}).join('');
}

function renderArchival(items, isInherited = false) {
    if (!items || items.length === 0) return '';
    const inheritedClass = isInherited ? 'inherited' : '';

    return items.map(item => `
        <div class="archival-item ${inheritedClass}">
            <div class="archival-tags">
                ${(item.tags || []).map(t => `<span class="archival-tag">${escapeHtml(t)}</span>`).join('')}
            </div>
            <div class="archival-text">${escapeHtml(item.text)}</div>
        </div>
    `).join('');
}

// Memory operation type classification
// Based on docs/memory.md - MemGPT-style memory API
const MEMORY_OP_TYPES = {
    // === Prompt Injection ===
    'render_for_prompt': { type: 'read', label: 'Memory Injection', category: 'injection' },

    // === Core Memory (always-visible key-value store) ===
    'mem_core_get': { type: 'read', label: 'Core Get', category: 'core' },
    'mem_core_set': { type: 'write', label: 'Core Set', category: 'core' },
    'mem_core_del': { type: 'write', label: 'Core Delete', category: 'core' },
    'set_core': { type: 'write', label: 'Core Set (legacy)', category: 'core' },
    'get_core': { type: 'read', label: 'Core Get (legacy)', category: 'core' },

    // === Recall Memory (recent events timeline) ===
    'mem_recall_append': { type: 'write', label: 'Recall Append', category: 'recall' },
    'mem_recall_search': { type: 'read', label: 'Recall Search', category: 'recall' },
    'recall_evict': { type: 'write', label: 'Recall Evict', category: 'recall' },
    'recall_summarize': { type: 'write', label: 'Recall Summarize', category: 'recall' },

    // === Archival Memory (searchable long-term store) ===
    'mem_archival_write': { type: 'write', label: 'Archival Write', category: 'archival' },
    'mem_archival_update': { type: 'write', label: 'Archival Update', category: 'archival' },
    'mem_archival_search': { type: 'read', label: 'Archival Search', category: 'archival' },
    'mem_archival_get': { type: 'read', label: 'Archival Get', category: 'archival' },
    'write_archival': { type: 'write', label: 'Archival Write (legacy)', category: 'archival' },
    'retrieve_archival': { type: 'read', label: 'Archival Retrieve (legacy)', category: 'archival' },

    // === Node Operations ===
    'mem_node_fork': { type: 'fork', label: 'Node Fork', category: 'node' },
    'mem_node_read': { type: 'read', label: 'Node Read', category: 'node' },
    'mem_node_write': { type: 'write', label: 'Node Write (batch)', category: 'node' },

    // === Memory Management ===
    'check_memory_pressure': { type: 'system', label: 'Pressure Check', category: 'management' },
    'consolidate': { type: 'system', label: 'Consolidation', category: 'management' },
    'importance_evaluation': { type: 'system', label: 'Importance Eval', category: 'management' },

    // === LLM Memory Operations (via <memory_update>) ===
    'llm_core_set': { type: 'llm', label: 'LLM Core Set', category: 'llm' },
    'llm_core_get': { type: 'llm', label: 'LLM Core Get', category: 'llm' },
    'llm_core_delete': { type: 'llm', label: 'LLM Core Delete', category: 'llm' },
    'llm_archival_write': { type: 'llm', label: 'LLM Archival Write', category: 'llm' },
    'llm_archival_search': { type: 'llm', label: 'LLM Archival Search', category: 'llm' },
    'llm_archival_update': { type: 'llm', label: 'LLM Archival Update', category: 'llm' },
    'llm_recall_append': { type: 'llm', label: 'LLM Recall Append', category: 'llm' },
    'llm_recall_search': { type: 'llm', label: 'LLM Recall Search', category: 'llm' },
    'llm_recall_evict': { type: 'llm', label: 'LLM Recall Evict', category: 'llm' },
    'llm_recall_summarize': { type: 'llm', label: 'LLM Recall Summarize', category: 'llm' },
    'llm_consolidate': { type: 'llm', label: 'LLM Consolidate', category: 'llm' },
};

function renderMemoryCalls(items, isInherited = false) {
    if (!items || items.length === 0) return '';
    const inheritedClass = isInherited ? 'inherited' : '';

    return items.map(item => {
        const op = item.op || 'unknown';
        const opInfo = MEMORY_OP_TYPES[op] || { type: 'other', label: op };
        const opType = opInfo.type;
        const opLabel = opInfo.label;
        const phase = item.phase || 'N/A';
        const ts = item.ts ? new Date(item.ts * 1000).toLocaleTimeString() : '';
        const details = item.details || {};

        // Format details based on operation type
        let detailsHtml = '';
        const category = opInfo.category || 'other';

        if (op === 'render_for_prompt') {
            // Memory injection into prompt
            detailsHtml = `
                <div class="memory-call-details">
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Budget:</span>
                        <span class="memory-call-detail-value">${details.budget_chars?.toLocaleString() || 'N/A'} chars</span>
                    </div>
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Core items:</span>
                        <span class="memory-call-detail-value">${details.core_count || 0}</span>
                    </div>
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Recall items:</span>
                        <span class="memory-call-detail-value">${details.recall_count || 0}</span>
                    </div>
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Archival items:</span>
                        <span class="memory-call-detail-value">${details.archival_count || 0}</span>
                    </div>
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Resource items:</span>
                        <span class="memory-call-detail-value">${details.resource_items || 0}</span>
                    </div>
                </div>`;
        } else if (op === 'mem_recall_append') {
            // Recall event append
            detailsHtml = `
                <div class="memory-call-details">
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Kind:</span>
                        <span class="memory-call-detail-value">${details.kind || 'N/A'}</span>
                    </div>
                    ${details.summary_preview ? `
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Summary:</span>
                        <span class="memory-call-detail-value">${escapeHtml(details.summary_preview.substring(0, 200))}${details.summary_preview.length > 200 ? '...' : ''}</span>
                    </div>` : ''}
                </div>`;
        } else if (op === 'mem_node_fork') {
            // Node fork operation
            detailsHtml = `
                <div class="memory-call-details">
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Parent Node:</span>
                        <span class="memory-call-detail-value">${details.parent_node_id ? details.parent_node_id.substring(0, 12) + '...' : 'None (root)'}</span>
                    </div>
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Child Branch:</span>
                        <span class="memory-call-detail-value">${details.child_branch_id ? details.child_branch_id.substring(0, 12) + '...' : 'N/A'}</span>
                    </div>
                </div>`;
        } else if (category === 'core' && (op.includes('set') || op.includes('del'))) {
            // Core memory set/delete
            const keys = details.keys || (details.key ? [details.key] : []);
            detailsHtml = keys.length > 0 ? `
                <div class="memory-call-details">
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Keys:</span>
                        <span class="memory-call-detail-value">${escapeHtml(keys.join(', '))}</span>
                    </div>
                </div>` : '';
        } else if (category === 'archival' && op.includes('search')) {
            // Archival search
            detailsHtml = `
                <div class="memory-call-details">
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Query:</span>
                        <span class="memory-call-detail-value">${escapeHtml(details.query || 'N/A')}</span>
                    </div>
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Results:</span>
                        <span class="memory-call-detail-value">${details.k || details.result_count || 'N/A'}</span>
                    </div>
                    ${details.tags ? `
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Tags:</span>
                        <span class="memory-call-detail-value">${escapeHtml(details.tags.join(', '))}</span>
                    </div>` : ''}
                </div>`;
        } else if (category === 'archival' && (op.includes('write') || op.includes('update'))) {
            // Archival write/update
            detailsHtml = `
                <div class="memory-call-details">
                    ${details.text ? `
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Text:</span>
                        <span class="memory-call-detail-value">${escapeHtml(String(details.text).substring(0, 150))}${String(details.text).length > 150 ? '...' : ''}</span>
                    </div>` : ''}
                    ${details.tags ? `
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Tags:</span>
                        <span class="memory-call-detail-value">${escapeHtml(details.tags.join(', '))}</span>
                    </div>` : ''}
                </div>`;
        } else if (op === 'check_memory_pressure') {
            // Memory pressure check
            detailsHtml = `
                <div class="memory-call-details">
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Pressure:</span>
                        <span class="memory-call-detail-value">${details.pressure_level || details.pressure || 'N/A'}</span>
                    </div>
                    ${details.usage_percent !== undefined ? `
                    <div class="memory-call-detail-row">
                        <span class="memory-call-detail-key">Usage:</span>
                        <span class="memory-call-detail-value">${(details.usage_percent * 100).toFixed(1)}%</span>
                    </div>` : ''}
                </div>`;
        } else if (category === 'llm') {
            // LLM-initiated memory operations
            let llmDetails = [];
            if (details.keys) llmDetails.push(`Keys: ${details.keys.join(', ')}`);
            if (details.query) llmDetails.push(`Query: ${details.query}`);
            if (details.text) llmDetails.push(`Text: ${String(details.text).substring(0, 100)}...`);
            if (details.kind) llmDetails.push(`Kind: ${details.kind}`);
            if (details.count !== undefined) llmDetails.push(`Count: ${details.count}`);
            detailsHtml = llmDetails.length > 0 ? `
                <div class="memory-call-details">
                    ${llmDetails.map(d => `<div class="memory-call-detail-row"><span class="memory-call-detail-value">${escapeHtml(d)}</span></div>`).join('')}
                </div>` : '';
        } else if (Object.keys(details).length > 0) {
            // Generic fallback for other operations
            const detailRows = Object.entries(details).slice(0, 5).map(([k, v]) => `
                <div class="memory-call-detail-row">
                    <span class="memory-call-detail-key">${escapeHtml(k)}:</span>
                    <span class="memory-call-detail-value">${escapeHtml(String(v).substring(0, 100))}</span>
                </div>`).join('');
            detailsHtml = `<div class="memory-call-details">${detailRows}</div>`;
        }

        return `
        <div class="memory-call-item ${opType} ${inheritedClass}">
            <div class="memory-call-header">
                <span class="memory-call-op ${opType}">${escapeHtml(opLabel)}</span>
                <span class="memory-call-time">${ts}</span>
            </div>
            <div class="memory-call-phase">Phase: ${escapeHtml(phase)}</div>
            ${detailsHtml}
        </div>
    `}).join('');
}

function renderAncestorChain(ancestors) {
    if (!ancestors || ancestors.length === 0) return '';
    const links = ancestors.map(a =>
        `<a onclick="selectNode(${a.index})">${a.node_uid ? a.node_uid.substring(0, 8) + '...' : 'Node ' + a.index}</a>`
    ).join(' ‚Üí ');
    return `<div class="ancestor-chain">Á∂ôÊâøÂÖÉ: ${links}</div>`;
}

function displayAllMemory(nodeData) {
    const container = document.getElementById('memory-content');

    // Use own_* fields if available, fall back to legacy fields
    const ownCoreKV = nodeData.own_core_kv || nodeData.core_kv || [];
    const ownEvents = nodeData.own_events || nodeData.events || [];
    const ownArchival = nodeData.own_archival || nodeData.archival || [];
    const ownMemoryCalls = nodeData.own_memory_calls || nodeData.memory_calls || [];
    const inheritedCoreKV = nodeData.inherited_core_kv || [];
    const inheritedEvents = nodeData.inherited_events || [];
    const inheritedArchival = nodeData.inherited_archival || [];
    const inheritedMemoryCalls = nodeData.inherited_memory_calls || [];
    const ancestors = nodeData.ancestors || [];

    let html = '';

    // Own data (this node's data)
    html += '<div class="data-group"><div class="data-group-header">„Åì„ÅÆ„Éé„Éº„Éâ„ÅÆ„Éá„Éº„Çø</div>';

    html += createSection(
        'Memory Operations Log',
        renderMemoryCalls(ownMemoryCalls),
        ownMemoryCalls.length,
        true
    );

    html += createSection(
        'Working Context (Core KV)',
        renderCoreKV(ownCoreKV),
        ownCoreKV.length,
        true
    );

    html += createSection(
        'Recall Storage (Events)',
        renderEvents(ownEvents),
        ownEvents.length,
        true
    );

    html += createSection(
        'Archive Storage',
        renderArchival(ownArchival),
        ownArchival.length,
        true
    );

    html += '</div>';

    // Inherited data (from ancestors)
    const hasInherited = inheritedCoreKV.length + inheritedEvents.length + inheritedArchival.length + inheritedMemoryCalls.length > 0;

    if (hasInherited) {
        html += '<div class="data-group"><div class="data-group-header inherited">Á∂ôÊâø„Åï„Çå„Åü„Éá„Éº„ÇøÔºàÁ•ñÂÖà„Éé„Éº„Éâ„Åã„ÇâÔºâ</div>';
        html += renderAncestorChain(ancestors);

        html += createSection(
            'Memory Operations Log',
            renderMemoryCalls(inheritedMemoryCalls, true),
            inheritedMemoryCalls.length,
            false
        );

        html += createSection(
            'Working Context (Core KV)',
            renderCoreKV(inheritedCoreKV, true),
            inheritedCoreKV.length,
            false
        );

        html += createSection(
            'Recall Storage (Events)',
            renderEvents(inheritedEvents, true),
            inheritedEvents.length,
            false
        );

        html += createSection(
            'Archive Storage',
            renderArchival(inheritedArchival, true),
            inheritedArchival.length,
            false
        );

        html += '</div>';
    }

    container.innerHTML = html;
}

function displayPhaseMemory(nodeData, phase) {
    const container = document.getElementById('memory-content');

    // Use own_* fields if available, fall back to legacy fields
    const ownCoreKV = nodeData.own_core_kv || nodeData.core_kv || [];
    const ownEvents = nodeData.own_events || nodeData.events || [];
    const ownArchival = nodeData.own_archival || nodeData.archival || [];
    const ownMemoryCalls = nodeData.own_memory_calls || nodeData.memory_calls || [];
    const inheritedCoreKV = nodeData.inherited_core_kv || [];
    const inheritedEvents = nodeData.inherited_events || [];
    const inheritedArchival = nodeData.inherited_archival || [];
    const inheritedMemoryCalls = nodeData.inherited_memory_calls || [];
    const ancestors = nodeData.ancestors || [];

    // Filter by phase
    const ownPhaseEvents = ownEvents.filter(e => e.phase === phase);
    const ownPhaseArchival = ownArchival.filter(a => a.phase === phase);
    const ownPhaseMemoryCalls = ownMemoryCalls.filter(m => m.phase === phase || m.phase?.includes(phase));
    const inheritedPhaseEvents = inheritedEvents.filter(e => e.phase === phase);
    const inheritedPhaseArchival = inheritedArchival.filter(a => a.phase === phase);
    const inheritedPhaseMemoryCalls = inheritedMemoryCalls.filter(m => m.phase === phase || m.phase?.includes(phase));

    let html = '';

    // Own data
    html += '<div class="data-group"><div class="data-group-header">„Åì„ÅÆ„Éé„Éº„Éâ„ÅÆ„Éá„Éº„Çø</div>';

    html += createSection(
        `Memory Operations Log - ${phase}`,
        renderMemoryCalls(ownPhaseMemoryCalls),
        ownPhaseMemoryCalls.length,
        true
    );

    html += createSection(
        'Working Context (Core KV)',
        renderCoreKV(ownCoreKV),
        ownCoreKV.length,
        true
    );

    html += createSection(
        `Recall Storage - ${phase}`,
        renderEvents(ownPhaseEvents),
        ownPhaseEvents.length,
        true
    );

    html += createSection(
        `Archive Storage - ${phase}`,
        renderArchival(ownPhaseArchival),
        ownPhaseArchival.length,
        true
    );

    html += '</div>';

    // Inherited data
    const hasInherited = inheritedCoreKV.length + inheritedPhaseEvents.length + inheritedPhaseArchival.length + inheritedPhaseMemoryCalls.length > 0;

    if (hasInherited) {
        html += '<div class="data-group"><div class="data-group-header inherited">Á∂ôÊâø„Åï„Çå„Åü„Éá„Éº„ÇøÔºàÁ•ñÂÖà„Éé„Éº„Éâ„Åã„ÇâÔºâ</div>';
        html += renderAncestorChain(ancestors);

        html += createSection(
            `Memory Operations Log - ${phase}`,
            renderMemoryCalls(inheritedPhaseMemoryCalls, true),
            inheritedPhaseMemoryCalls.length,
            false
        );

        html += createSection(
            'Working Context (Core KV)',
            renderCoreKV(inheritedCoreKV, true),
            inheritedCoreKV.length,
            false
        );

        html += createSection(
            `Recall Storage - ${phase}`,
            renderEvents(inheritedPhaseEvents, true),
            inheritedPhaseEvents.length,
            false
        );

        html += createSection(
            `Archive Storage - ${phase}`,
            renderArchival(inheritedPhaseArchival, true),
            inheritedPhaseArchival.length,
            false
        );

        html += '</div>';
    }

    container.innerHTML = html;
}

new p5(createSketch());
    </script>
</body>
</html>
